<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virgil — Task Diagram</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --fg: #e0e0e0;
      --accent: #00d4ff;
      --muted: #666;
      --success: #4caf50;
      --warning: #ff9800;
      --error: #f44336;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      background: var(--bg);
      color: var(--fg);
      padding: 1.5rem;
      min-height: 100vh;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--muted);
      padding-bottom: 0.75rem;
    }
    header h1 {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--accent);
    }
    header h1 span { color: var(--muted); font-weight: 400; }
    #clock { color: var(--muted); font-size: 0.85rem; }
    #status-bar {
      display: flex;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
      font-size: 0.8rem;
      color: var(--muted);
    }
    #status-bar .stat { display: flex; gap: 0.3rem; }
    #status-bar .stat .value { color: var(--fg); }
    #diagram-container {
      background: #16213e;
      border-radius: 8px;
      padding: 1.5rem;
      min-height: 400px;
      overflow: auto;
    }
    #no-data {
      text-align: center;
      color: var(--muted);
      padding: 4rem 1rem;
      font-size: 0.9rem;
    }
    #no-data code {
      background: #0f3460;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      font-size: 0.8rem;
    }
    #error-msg {
      color: var(--error);
      font-size: 0.8rem;
      margin-top: 0.5rem;
      display: none;
    }
    footer {
      margin-top: 1.5rem;
      font-size: 0.7rem;
      color: var(--muted);
      text-align: center;
    }
    /* Mermaid theme overrides */
    .mermaid { text-align: center; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
</head>
<body>
  <header>
    <h1>VIRGIL <span>— Task Diagram</span></h1>
    <span id="clock"></span>
  </header>

  <div id="status-bar">
    <div class="stat">Tasks: <span class="value" id="task-count">—</span></div>
    <div class="stat">Completed: <span class="value" id="completed-count">—</span></div>
    <div class="stat">In Progress: <span class="value" id="progress-count">—</span></div>
    <div class="stat">Last Update: <span class="value" id="last-update">—</span></div>
  </div>

  <div id="diagram-container">
    <div id="no-data">
      Waiting for task data...<br><br>
      Virgil reads from <code>.virgil-tasks.json</code><br>
      Generated by <code>virgil.sh</code> or <code>TodoWrite</code> events
    </div>
    <div class="mermaid" id="mermaid-target" style="display:none;"></div>
  </div>

  <div id="error-msg"></div>

  <footer>Virgil v0.1 — Aion Script Codebase Guide — localhost:8377</footer>

  <script>
    // Mermaid config: dark theme
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      flowchart: { curve: 'basis', padding: 15 },
      themeVariables: {
        primaryColor: '#0f3460',
        primaryTextColor: '#e0e0e0',
        primaryBorderColor: '#00d4ff',
        lineColor: '#666',
        secondaryColor: '#1a1a2e',
        tertiaryColor: '#16213e'
      }
    });

    const DATA_URL = '.virgil-tasks.json';
    const POLL_INTERVAL = 5000; // 5 seconds

    // Clock
    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent =
        now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', timeZoneName: 'short' });
    }

    // Convert task list to Mermaid flowchart
    function tasksToMermaid(tasks) {
      if (!tasks || tasks.length === 0) return null;

      let lines = ['graph TD'];
      let nodeId = 0;
      const idMap = {};

      // Assign IDs
      tasks.forEach(t => {
        const id = `T${nodeId++}`;
        idMap[t.id || t.subject] = id;
      });

      // Build nodes and edges
      tasks.forEach(t => {
        const key = t.id || t.subject;
        const id = idMap[key];
        const label = t.subject || key;
        const status = (t.status || 'pending').toLowerCase();

        // Node shape by status
        if (status === 'completed') {
          lines.push(`  ${id}[/"${label}" ✓/]`);
          lines.push(`  style ${id} fill:#1b5e20,stroke:#4caf50,color:#e0e0e0`);
        } else if (status === 'in_progress') {
          lines.push(`  ${id}[["${label}" ⟳"]]`);
          lines.push(`  style ${id} fill:#e65100,stroke:#ff9800,color:#e0e0e0`);
        } else {
          lines.push(`  ${id}["${label}"]`);
          lines.push(`  style ${id} fill:#0f3460,stroke:#00d4ff,color:#e0e0e0`);
        }

        // Dependencies
        if (t.blockedBy && Array.isArray(t.blockedBy)) {
          t.blockedBy.forEach(dep => {
            const depId = idMap[dep];
            if (depId) lines.push(`  ${depId} --> ${id}`);
          });
        }

        // Subtasks
        if (t.subtasks && Array.isArray(t.subtasks)) {
          t.subtasks.forEach(sub => {
            const subKey = sub.id || sub.subject;
            if (idMap[subKey]) {
              lines.push(`  ${id} --> ${idMap[subKey]}`);
            }
          });
        }
      });

      return lines.join('\n');
    }

    // Update stats bar
    function updateStats(tasks) {
      const total = tasks.length;
      const completed = tasks.filter(t => (t.status || '').toLowerCase() === 'completed').length;
      const inProgress = tasks.filter(t => (t.status || '').toLowerCase() === 'in_progress').length;

      document.getElementById('task-count').textContent = total;
      document.getElementById('completed-count').textContent = completed;
      document.getElementById('progress-count').textContent = inProgress;
      document.getElementById('last-update').textContent =
        new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    // Render diagram
    async function renderDiagram(tasks) {
      const mermaidDef = tasksToMermaid(tasks);
      if (!mermaidDef) return;

      const target = document.getElementById('mermaid-target');
      const noData = document.getElementById('no-data');

      try {
        const { svg } = await mermaid.render('mermaid-svg', mermaidDef);
        target.innerHTML = svg;
        target.style.display = 'block';
        noData.style.display = 'none';
        document.getElementById('error-msg').style.display = 'none';
      } catch (e) {
        document.getElementById('error-msg').textContent = `Render error: ${e.message}`;
        document.getElementById('error-msg').style.display = 'block';
      }
    }

    // Poll for task data
    let lastData = '';
    async function poll() {
      try {
        const resp = await fetch(DATA_URL, { cache: 'no-store' });
        if (!resp.ok) return; // File not yet created
        const text = await resp.text();
        if (text === lastData) return; // No changes
        lastData = text;

        const data = JSON.parse(text);
        const tasks = data.tasks || data;
        updateStats(tasks);
        await renderDiagram(tasks);
      } catch (e) {
        // Silently ignore fetch/parse errors (file may not exist yet)
      }
    }

    // Start
    updateClock();
    setInterval(updateClock, 1000);
    poll();
    setInterval(poll, POLL_INTERVAL);
  </script>
</body>
</html>
